---
title: Composite Connections
description: Virtual aggregation of multiple embedded databases.
---

# Composite Connections

Virtual aggregation of multiple embedded databases.

## Overview

db-yard supports many small, purpose-built SQLite databases per tenant and functional area. The composite connection pattern provides a single connection surface for querying across multiple databases without forcing consolidation.

## Key Concepts

### Embedded Databases

All databases in db-yard are embedded (file-based):
- SQLite
- DuckDB

They are accessed via local paths, not through a server process.

### Multiple Databases

Each tenant/purpose may have many databases:
- Evidence warehouses
- Qualityfolio data
- Fleetfolio data
- Telemetry stores

### Composite Databases

A composite is a thin database whose primary role is to:
1. ATTACH other databases
2. Optionally define views across them
3. Provide a stable connection surface

The composite doesn't own underlying data - it's purely for aggregation.

## Directory Layout

Standard structure:

```
<volume>/
  embedded/
    admin/
      db0.sqlite.db
      composite.sql
      composite.sqlite.auto.db

    cross-tenant/
      db1.sqlite.db
      db2.sqlite.db
      composite.sql
      composite.sqlite.auto.db

    tenant/
      <tenantID>/
        db3.sqlite.db
        db4.sqlite.db
        composite.sql
        composite.sqlite.auto.db
```

### Scopes

| Scope | Purpose |
|-------|---------|
| `admin` | Internal administrative databases |
| `cross-tenant` | Platform-level reporting and analytics |
| `tenant/<id>` | Tenant-specific databases |

### Naming Conventions

| File | Purpose |
|------|---------|
| `composite.sql` | Canonical SQL definition (source of truth) |
| `composite.sqlite.auto.db` | Generated database (disposable) |

## How SQLite ATTACH Works

SQLite allows a single connection to attach additional database files:

```sql
ATTACH DATABASE 'db3.sqlite.db' AS qualityfolio;
ATTACH DATABASE 'db4.sqlite.db' AS fleetfolio;
```

After attaching, tables are referenced with schema prefixes:

```sql
SELECT * FROM qualityfolio.test_cases;
SELECT * FROM fleetfolio.assets;
```

## Generating Composites

### Using the CLI

```bash
# Admin scope (default)
./bin/yard.ts cc --volume-root /var/db-yard --scope admin

# Tenant scope
./bin/yard.ts cc --volume-root /var/db-yard --scope tenant --tenant-id tenant-123

# Cross-tenant scope
./bin/yard.ts cc --volume-root /var/db-yard --scope cross-tenant
```

### Output Example (SQLite)

```sql
-- Composite connection for admin scope
-- Generated by db-yard

PRAGMA journal_mode = WAL;
PRAGMA synchronous = NORMAL;

ATTACH DATABASE '/var/db-yard/embedded/admin/db0.sqlite.db' AS db0;
ATTACH DATABASE '/var/db-yard/embedded/admin/db1.sqlite.db' AS db1;
```

### Output Example (DuckDB)

```sql
-- Composite connection for cross-tenant scope
-- Generated by db-yard (DuckDB dialect)

INSTALL sqlite;
LOAD sqlite;

ATTACH '/var/db-yard/embedded/tenant/a/db.sqlite.db' AS tenant_a (TYPE sqlite);
ATTACH '/var/db-yard/embedded/tenant/b/db.sqlite.db' AS tenant_b (TYPE sqlite);
```

## Creating Views

Composites can define cross-database views:

```sql
-- In composite.sql
ATTACH DATABASE 'qualityfolio.db' AS qualityfolio;
ATTACH DATABASE 'fleetfolio.db' AS fleetfolio;

CREATE VIEW all_findings AS
SELECT 'quality' AS source, id, severity, created_at
FROM qualityfolio.findings
UNION ALL
SELECT 'fleet' AS source, id, severity, created_at
FROM fleetfolio.findings;
```

Applications query the unified view:

```sql
SELECT * FROM all_findings WHERE severity = 'critical';
```

## Composite Lifecycle

### 1. Author composite.sql

Write or generate the SQL definition:

```sql
ATTACH DATABASE 'db1.sqlite.db' AS db1;
CREATE VIEW unified_data AS SELECT * FROM db1.main_table;
```

### 2. Generate composite.sqlite.auto.db

```bash
# Remove old
rm composite.sqlite.auto.db

# Create new
sqlite3 composite.sqlite.auto.db < composite.sql
```

### 3. Application Usage

Connect only to the composite:

```typescript
const db = new Database("composite.sqlite.auto.db");
const results = db.query("SELECT * FROM unified_data");
```

## Read-Only vs Read-Write

### Recommended: Read-Only Default

Open composites in read-only mode:

```typescript
const db = new Database("composite.sqlite.auto.db", { readonly: true });
```

### Write Access

For writes, prefer:
1. Direct connection to the target database
2. WAL mode for concurrent access
3. Short transactions

### PRAGMA Settings

Typical composite.sql settings:

```sql
PRAGMA journal_mode = WAL;
PRAGMA synchronous = NORMAL;
```

## DuckDB Analytics

For advanced analytics, DuckDB can aggregate SQLite databases:

### Installing SQLite Extension

```sql
INSTALL sqlite;
LOAD sqlite;
```

### Attaching SQLite Databases

```sql
ATTACH 'tenant/a/db.sqlite.db' AS tenant_a (TYPE sqlite);
ATTACH 'tenant/b/db.sqlite.db' AS tenant_b (TYPE sqlite);
```

### Analytics Views

```sql
CREATE VIEW all_test_results AS
SELECT 'tenant_a' AS tenant, * FROM tenant_a.test_results
UNION ALL
SELECT 'tenant_b' AS tenant, * FROM tenant_b.test_results;
```

### Use Cases

- Large cross-tenant scans
- Heavy aggregations
- Time-series analytics
- Materialized rollups

## Architecture Diagram

```
               Single Connection
                      |
                      v
          +---------------------------+
          | composite.sqlite.auto.db  |
          |  - ATTACH qualityfolio    |
          |  - ATTACH fleetfolio      |
          |  - Views (optional)       |
          +---------------------------+
                      |
        +--------------+--------------+
        |                             |
        v                             v
+-------------------+       +-------------------+
| qualityfolio.db   |       | fleetfolio.db     |
| (Qualityfolio)    |       | (Fleetfolio)      |
+-------------------+       +-------------------+
```

## Query Flow

```
Application Query
  SELECT * FROM all_findings;
        |
        v
Composite Resolves View
  all_findings = UNION ALL
    SELECT ... FROM qualityfolio.findings
    SELECT ... FROM fleetfolio.findings
        |
        v
Attached DB Resolution
  qualityfolio.* -> qualityfolio.db
  fleetfolio.*   -> fleetfolio.db
```

## Best Practices

### Security

- Never accept user input as ATTACH paths
- Maintain controlled mapping from names to paths
- Treat composite.sql as configuration

### Operations

- Regenerate composites during deployment
- Add health checks for ATTACH targets
- Keep write transactions short

### Separation of Concerns

| Layer | Responsibility |
|-------|----------------|
| SQLite composites | Operational truth, evidence access |
| DuckDB composites | Analytics, reporting |

## Persistence Notes

### Ephemeral Usage

For transient queries, use `:memory:`:

```bash
sqlite3 :memory: < composite.sql
```

The ATTACH statements work but nothing persists.

### Persistent Composite

With a file-based composite:
- ATTACH statements run per-connection (not saved)
- CREATE VIEW/TABLE statements persist
- Requires regeneration on schema changes

---

See also: [RFC: Composite Connections](../../support/rfc/composite.md)